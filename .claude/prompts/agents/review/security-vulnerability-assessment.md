# Security Vulnerability Assessment

**Agent: reviewer**
**Purpose: Conduct comprehensive security vulnerability assessments using automated tools and manual analysis**

---

## üéØ Mission

Perform systematic security vulnerability assessments to identify, prioritize, and remediate security weaknesses before they can be exploited in production environments.

## üìã Security Assessment Process

### Step 1: Vulnerability Scanning Setup

**OWASP ZAP Integration:**
```yaml
# .github/workflows/security-scan.yml
name: Security Vulnerability Scan

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * 1'  # Weekly Monday 2 AM

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Application
      run: |
        docker-compose up -d
        sleep 30  # Wait for app to be ready
        
    - name: OWASP ZAP Baseline Scan
      uses: zaproxy/action-baseline@v0.7.0
      with:
        target: 'http://localhost:3000'
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a -j -l PASS -z "-config scanner.strength=HIGH"'
        
    - name: OWASP ZAP Full Scan
      uses: zaproxy/action-full-scan@v0.4.0
      with:
        target: 'http://localhost:3000'
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a -j -l PASS'
        
    - name: Snyk Security Scan
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=high --fail-on=all
        
    - name: Trivy Container Scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'myapp:latest'
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: CodeQL Analysis
      uses: github/codeql-action/init@v2
      with:
        languages: javascript, python
        queries: security-and-quality
        
    - name: Upload Security Reports
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: trivy-results.sarif
```

**Snyk Configuration:**
```json
{
  "language-settings": {
    "javascript": {
      "includeDevDependencies": false,
      "ignoreUnfixable": false
    },
    "python": {
      "pipfileSupport": true,
      "includeDevDependencies": false
    }
  },
  "severity-threshold": "high",
  "ignore": {
    "SNYK-JS-LODASH-567746": {
      "reason": "Not exploitable in our use case",
      "expires": "2024-12-31T23:59:59.999Z"
    }
  },
  "patches": {},
  "version": "v1.0.0"
}
```

### Step 2: SAST (Static Application Security Testing)

**SemGrep Security Rules:**
```yaml
# .semgrep.yml
rules:
  - id: sql-injection-risk
    pattern: |
      db.query($SQL, ...)
    message: Potential SQL injection vulnerability
    severity: ERROR
    languages: [javascript, python]
    metadata:
      cwe: "CWE-89"
      owasp: "A03:2021 - Injection"
      
  - id: xss-vulnerability
    pattern: |
      res.send($USER_INPUT)
    message: Potential XSS vulnerability - user input not sanitized
    severity: ERROR
    languages: [javascript]
    metadata:
      cwe: "CWE-79"
      owasp: "A03:2021 - Injection"
      
  - id: hardcoded-secrets
    pattern-regex: |
      (password|secret|key|token)\s*=\s*[\"'][^\"']+[\"']
    message: Hardcoded secret detected
    severity: ERROR
    languages: [javascript, python, java]
    metadata:
      cwe: "CWE-798"
      owasp: "A07:2021 - Identification and Authentication Failures"

  - id: insecure-random
    pattern: |
      Math.random()
    message: Math.random() is not cryptographically secure
    severity: WARNING
    languages: [javascript]
    metadata:
      cwe: "CWE-338"
      
  - id: path-traversal
    pattern: |
      fs.readFile($PATH, ...)
    message: Potential path traversal vulnerability
    severity: ERROR
    languages: [javascript]
    metadata:
      cwe: "CWE-22"
      owasp: "A01:2021 - Broken Access Control"
```

**Custom Security Analysis Script:**
```python
# security_analyzer.py
import subprocess
import json
import requests
from datetime import datetime
import yaml

class SecurityVulnerabilityAssessment:
    def __init__(self, project_path, config_file):
        self.project_path = project_path
        self.config = self.load_config(config_file)
        self.results = {}
        
    def run_comprehensive_scan(self):
        """Execute all security scanning tools"""
        print("üîç Starting comprehensive security assessment...")
        
        # Static analysis
        self.results['sast'] = self.run_sast_scan()
        
        # Dependency scanning
        self.results['dependencies'] = self.run_dependency_scan()
        
        # Container scanning
        self.results['containers'] = self.run_container_scan()
        
        # Infrastructure scanning
        self.results['infrastructure'] = self.run_infrastructure_scan()
        
        # Generate consolidated report
        report = self.generate_security_report()
        self.save_report(report)
        
        return report
    
    def run_sast_scan(self):
        """Run static application security testing"""
        tools = ['semgrep', 'bandit', 'eslint-security']
        results = {}
        
        for tool in tools:
            print(f"  Running {tool} scan...")
            if tool == 'semgrep':
                results[tool] = self.run_semgrep()
            elif tool == 'bandit':
                results[tool] = self.run_bandit()
            elif tool == 'eslint-security':
                results[tool] = self.run_eslint_security()
                
        return results
    
    def run_semgrep(self):
        """Execute SemGrep security analysis"""
        cmd = [
            'semgrep',
            '--config=auto',
            '--config=.semgrep.yml',
            '--json',
            '--output=semgrep-results.json',
            self.project_path
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            with open('semgrep-results.json', 'r') as f:
                return json.load(f)
        else:
            return {'error': result.stderr}
    
    def run_dependency_scan(self):
        """Scan dependencies for known vulnerabilities"""
        tools = ['snyk', 'npm-audit', 'pip-audit']
        results = {}
        
        # Snyk scan
        if self.has_package_json():
            snyk_cmd = ['snyk', 'test', '--json']
            result = subprocess.run(snyk_cmd, capture_output=True, text=True)
            results['snyk'] = json.loads(result.stdout) if result.returncode == 0 else {'error': result.stderr}
        
        # NPM audit
        if self.has_package_json():
            npm_cmd = ['npm', 'audit', '--json']
            result = subprocess.run(npm_cmd, capture_output=True, text=True)
            results['npm_audit'] = json.loads(result.stdout) if result.stdout else {'vulnerabilities': {}}
        
        return results
    
    def analyze_vulnerability_severity(self, vulnerabilities):
        """Classify and prioritize vulnerabilities"""
        severity_mapping = {
            'critical': {'score': 10, 'color': 'red', 'action': 'immediate'},
            'high': {'score': 8, 'color': 'orange', 'action': '24h'},
            'medium': {'score': 5, 'color': 'yellow', 'action': '1_week'},
            'low': {'score': 2, 'color': 'green', 'action': 'next_sprint'}
        }
        
        classified = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'low').lower()
            if severity in classified:
                classified[severity].append({
                    'id': vuln.get('id'),
                    'title': vuln.get('title'),
                    'description': vuln.get('description'),
                    'cwe': vuln.get('cwe'),
                    'owasp': vuln.get('owasp'),
                    'file': vuln.get('file'),
                    'line': vuln.get('line'),
                    'remediation': vuln.get('fix_guidance'),
                    'score': severity_mapping[severity]['score']
                })
        
        return classified
    
    def generate_executive_summary(self, vulnerabilities):
        """Create executive summary for stakeholders"""
        total = sum(len(v) for v in vulnerabilities.values())
        critical_count = len(vulnerabilities.get('critical', []))
        high_count = len(vulnerabilities.get('high', []))
        
        risk_level = 'LOW'
        if critical_count > 0:
            risk_level = 'CRITICAL'
        elif high_count > 5:
            risk_level = 'HIGH'
        elif high_count > 0:
            risk_level = 'MEDIUM'
        
        return {
            'total_vulnerabilities': total,
            'critical_vulnerabilities': critical_count,
            'high_vulnerabilities': high_count,
            'overall_risk_level': risk_level,
            'remediation_priority': self.get_remediation_priority(vulnerabilities),
            'compliance_impact': self.assess_compliance_impact(vulnerabilities),
            'recommendations': self.generate_recommendations(vulnerabilities)
        }
```

### Step 3: DAST (Dynamic Application Security Testing)

**OWASP ZAP Automation:**
```python
# zap_automation.py
from zapv2 import ZAPv2
import time
import json

class ZAPSecurityScanner:
    def __init__(self, target_url, zap_proxy='http://127.0.0.1:8080'):
        self.target = target_url
        self.zap = ZAPv2(proxies={'http': zap_proxy, 'https': zap_proxy})
        
    def run_full_security_scan(self):
        """Execute comprehensive DAST scan"""
        print(f"üï∑Ô∏è  Starting ZAP security scan for {self.target}")
        
        # Spider the application
        print("  Spidering application...")
        scanid = self.zap.spider.scan(self.target)
        self.wait_for_completion(scanid, self.zap.spider)
        
        # Passive scan
        print("  Running passive security scan...")
        self.zap.pscan.enable_all_scanners()
        
        # Active scan
        print("  Running active security scan...")
        scanid = self.zap.ascan.scan(self.target)
        self.wait_for_completion(scanid, self.zap.ascan)
        
        # Get results
        alerts = self.zap.core.alerts()
        return self.process_zap_results(alerts)
    
    def process_zap_results(self, alerts):
        """Process and categorize ZAP scan results"""
        categorized = {
            'High': [],
            'Medium': [], 
            'Low': [],
            'Informational': []
        }
        
        for alert in alerts:
            risk = alert.get('risk', 'Low')
            categorized[risk].append({
                'name': alert.get('alert'),
                'description': alert.get('desc'),
                'solution': alert.get('solution'),
                'reference': alert.get('reference'),
                'url': alert.get('url'),
                'param': alert.get('param'),
                'evidence': alert.get('evidence'),
                'cwe': alert.get('cweid'),
                'wascid': alert.get('wascid')
            })
        
        return categorized
    
    def wait_for_completion(self, scanid, scanner):
        """Wait for scan to complete"""
        while int(scanner.status(scanid)) < 100:
            print(f"    Progress: {scanner.status(scanid)}%")
            time.sleep(2)
        print("    Scan completed!")
```

### Step 4: Infrastructure Security Assessment

**Terraform Security Scanning:**
```yaml
# Infrastructure security scan
terraform_security:
  tools:
    - checkov
    - tfsec  
    - terrascan
    
  checkov_config:
    framework: ['terraform', 'kubernetes', 'docker']
    check: ['CKV_AWS_*', 'CKV_K8S_*']
    skip_check: ['CKV_AWS_79']  # Skip specific checks if needed
    
  tfsec_config:
    minimum_severity: 'HIGH'
    exclude_checks: ['AWS001']
    
  custom_rules:
    - name: "Ensure S3 buckets have encryption"
      resource_type: "aws_s3_bucket"
      condition: "encryption_configuration is not empty"
      severity: "HIGH"
```

## üö® Vulnerability Management

### Step 5: Risk Assessment and Prioritization

**CVSS Scoring Integration:**
```python
# cvss_calculator.py
class CVSSCalculator:
    def calculate_cvss_v3(self, metrics):
        """Calculate CVSS v3.1 score"""
        # Base metrics
        av = metrics.get('attack_vector', 'Network')  # Network, Adjacent, Local, Physical
        ac = metrics.get('attack_complexity', 'Low')  # Low, High
        pr = metrics.get('privileges_required', 'None')  # None, Low, High
        ui = metrics.get('user_interaction', 'None')  # None, Required
        scope = metrics.get('scope', 'Unchanged')  # Unchanged, Changed
        c = metrics.get('confidentiality', 'High')  # None, Low, High
        i = metrics.get('integrity', 'High')  # None, Low, High
        a = metrics.get('availability', 'High')  # None, Low, High
        
        # Convert to numeric values and calculate
        base_score = self._calculate_base_score(av, ac, pr, ui, scope, c, i, a)
        
        return {
            'base_score': base_score,
            'severity': self._get_severity_rating(base_score),
            'vector_string': self._generate_vector_string(metrics)
        }
    
    def prioritize_vulnerabilities(self, vulnerabilities):
        """Prioritize vulnerabilities based on multiple factors"""
        prioritized = []
        
        for vuln in vulnerabilities:
            score = 0
            
            # CVSS base score (40% weight)
            score += vuln.get('cvss_score', 0) * 0.4
            
            # Exploitability (25% weight)
            exploitability = vuln.get('exploitability', 'Unknown')
            exploit_score = {'High': 10, 'Medium': 6, 'Low': 3, 'Unknown': 1}
            score += exploit_score.get(exploitability, 1) * 0.25
            
            # Asset criticality (20% weight)
            asset_criticality = vuln.get('asset_criticality', 'Medium')
            asset_score = {'Critical': 10, 'High': 8, 'Medium': 5, 'Low': 2}
            score += asset_score.get(asset_criticality, 5) * 0.2
            
            # Business impact (15% weight)
            business_impact = vuln.get('business_impact', 'Medium')
            business_score = {'High': 10, 'Medium': 6, 'Low': 2}
            score += business_score.get(business_impact, 6) * 0.15
            
            vuln['priority_score'] = round(score, 2)
            prioritized.append(vuln)
        
        return sorted(prioritized, key=lambda x: x['priority_score'], reverse=True)
```

### Step 6: Remediation Planning

**Vulnerability Remediation Workflow:**
```yaml
# remediation_workflow.yml
remediation_process:
  immediate_action:  # Critical/High severity
    timeline: "24-48 hours"
    steps:
      - isolate_affected_systems
      - apply_temporary_mitigations
      - develop_permanent_fix
      - test_fix_thoroughly
      - deploy_with_monitoring
      - validate_remediation
      
  scheduled_remediation:  # Medium severity
    timeline: "1-2 weeks"
    steps:
      - schedule_maintenance_window
      - prepare_remediation_plan
      - coordinate_with_stakeholders
      - implement_fix
      - post_implementation_testing
      
  planned_improvement:  # Low severity
    timeline: "Next sprint/release"
    steps:
      - add_to_product_backlog
      - prioritize_against_features
      - include_in_sprint_planning
      - implement_during_development
      
  tracking:
    - vulnerability_id
    - discovery_date
    - severity_level
    - assigned_owner
    - remediation_plan
    - target_completion
    - actual_completion
    - validation_status
```

## üìä Security Metrics and Reporting

### Step 7: Security Dashboard

**Key Security Metrics:**
```json
{
  "security_metrics": {
    "vulnerability_trends": {
      "new_vulnerabilities_this_month": 15,
      "resolved_vulnerabilities_this_month": 22,
      "average_time_to_remediation": "5.2 days",
      "critical_vulnerabilities_open": 0,
      "high_severity_vulnerabilities_open": 3
    },
    "compliance_status": {
      "owasp_top_10_compliance": 85,
      "security_controls_implemented": 42,
      "security_controls_total": 50,
      "last_penetration_test": "2024-01-15",
      "next_security_audit": "2024-04-15"
    },
    "security_coverage": {
      "code_security_scan_coverage": 95,
      "dependency_scan_coverage": 100,
      "infrastructure_scan_coverage": 90,
      "dynamic_scan_coverage": 80
    }
  }
}
```

## üì§ Deliverables

- **Vulnerability Assessment Report** with risk ratings and recommendations
- **Security Dashboard** with real-time vulnerability metrics
- **Remediation Plan** with prioritized action items and timelines
- **Compliance Report** mapping findings to regulatory requirements
- **Security Tool Configuration** for automated scanning integration
- **Incident Response Procedures** for security vulnerability management
- **Executive Summary** with business impact and risk assessment

## ü§ù Collaboration Points

**With security-engineer:** Deep security analysis and remediation strategies
**With deployment-engineer:** Security tool integration in CI/CD pipelines
**With development agents:** Vulnerability remediation implementation
**With business-analyst:** Business impact assessment and risk communication
**With qa-engineer:** Security testing integration and validation procedures

---
*Comprehensive security vulnerability assessment ensures proactive identification and remediation of security risks before they can impact production systems.*